### 풀이

n : 짐칸 수  

m : 소형 기관차가 끌 수 있는 짐칸 수

연속된 짐칸을 선택해야한다 -> 연속된만큼 더해서 배열에 저장

짐칸

35 40 50 10 30 45 60

배열

[0, 75, 90, 60, 40, 75, 105]

그럼 해당 배열의 원소를 선택 하나 안하냐의 문제로 바뀌게 된다
몇가지 조건을 신경쓰는 0-1 배낭 문제로 풀 수 있다

> 조건
> 
> 1. 3개만 선택한다
> 2. 선택 원소 i 와 j 간의 차이가 m 이상 나야함

위 내용을 포함하려면 
1. 현재 상황은 몇 개까지 고른 상태인지
2. 고른 원소간 차이가 난다는 것을 알 수 있는지

를 고려한 식을 작성하면된다 


DP[몇개][현재 원소][현재원소를 뽑았는지] 로 산정한다

```java

dp[k][i][true] = max(dp[k-1][i-m][true], dp[k-1][i-m][false])

dp[k][i][true] = max(dp[k][i-1][true], dp[k][i-1][false])
```

위의 dp 배열을 iterative하게 채우고 
max(dp[3][n-m+1][true], dp[3][n-m+1][false])를 해주면 끝


---

수정

DP식 수정을 해도 될 듯하다

```java
dp[k][i] = max(dp[k-1][i-m] + 현재 칸 사람수 , dp[k-1][i-1])
```