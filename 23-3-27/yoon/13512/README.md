13512

HLD 로 풀면 좀 쉽겠는데?

---

dfs1에서 양방향 간선 처리 우아하게 하는 방법 없나?


13510 참고하면서 든 의문

1. dfs1에서 tree[0], prev 처리 확실히 했나?
    
    아닌거같아서 수정했음.

2. top[next] 정할 때, tree[here][0]이랑 같은 값이 두개면 어떻게 처리되나?
    
    이번엔 idx로 판별했음.

---

체인에서 [top, idx] 내에서 가장 높은 인덱스를 알고싶음.

만약 업데이트를 걍 depth 기준 우선순위로 단일 업데이트로 처리하면?

값 없어진다고 해도 max 때려서 처리하면 문제될 거 없음.

그럼 구하는거는? 범위로 때리면 됨. 이거네.

---

seg root엔 머 들어가야하나.

depth가 더 큰 idx? pair<int, int> 써야할 거같은데.

{depth, euler ID}

toBe가 true => 검은색이 된다. => value가 존재.

find에서 찾고자 하는 것 : depth가 가장 낮은 origin ID

---
