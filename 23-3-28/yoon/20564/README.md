20564

서로 다른 모든 흰색 정점 쌍의 LCA

시간제한 5초에 N, M이 50만.

---

일단 특정 노드가 바뀔 때마다 다른 모든 노드에 LCA를 해준다고 생각해보면

$O(M * N * logN)$ 절대 불가능 !

**특정 노드가 바뀌는 게 어떤 효과가 있는지 파악한다.**
   
segment tree의 다른 노드들에는 지금 선택된 현 노드와의 관계 말고도 다른 LCA 값들도 들어가있을거란 말이지.

그렇기 때문에 출력만 따지면 아마 $O(1)$이라 생각함. [1, N] 범위 출력해주면 되니까.

seg 리프 노드에는 다른 노드들과의 LCA가 들어가있고, seg 중간 노드들은 그들의 합. 이면 가장 이상적인 그림이긴 함.

일단 처음에 다 검은 노드만 있다고 생각해보자.

먼가 노드를 흰색으로 칠하면

모든 체인에 대해서 한번 돌아. $log N * log N$

1. 체인 안

2. 체인 밖
    이 체인 밖의 연결고리인 1번 노드 아래 체인애들은 1번 노드 level을 더해줘야함.


---

선택한 노드 in[] 에선 다 더해주면 되는데

바깥꺼는 parent[] 하나씩 타고 올라가자니 $O(N)$ 맞을 것 같은데.

어떻게하면 바깥에 대해서 N을 안 맞을 수 있을까?

바깥 세계

a : 나

부모의 내 앞 자식들

부모의 내 뒷 자식들

부모 바깥 세계

---

b = out[a]

[b, out[b] - 1] += parent[b] // depth[parent[b]] != 0

---

내 체인 root 까지 LCA => 체인 각자 본인들

일렬이면 무조건 NlogN이잖아.. 한 쿼리에


segment tree root = [start, end] 누적 합

[in[a], out[a] - 1] 바깥에 대해서 어떻게 처리해야할지 모르겠네..
O(N)인데..

[2, in[a] - 1]만 처리하면 될거같은데?

내 위엣놈들 더해주는거 O(N)보다 작게 처리하기?

하나씩 차근차근 가서는 답이 없는데.

체인 개념 써야 무조건 N보다 작은데.. 흠..

아니면 각 노드엔 본인 서브노드의 흰색 개수가 저장되어있으면?

update에는 logN이 들겠지. -- 해주면서 드가니까.

출력에는?

---

각 노드에 서브 트리의 흰색 노드 개수가 들어가게 되면

update는 해당 노드에서 루트 노드까지라서 체인으로 $O(logN * logN)$이 가능하게 됨 !

출력 계산

(해당 노드 서브 트리 개수 - 이전 노드 서브 트리 개수) * 해당 노드 depth

출력 계산도 좀 미리미리 해놓을 수 없나?

리프노드 => 각 노드의 서브트리 흰색 개수

[a, a + 2], a의 depth는 d

sub[a + 2] * (d + 2) +

(sub[a + 1] - sub[a + 2]) * (d + 1) + 

(sub[a] - sub[a + 1]) * d

= 

sub[a] * (d) + 

sub[a + 1] * (d + 1 - d) +

sub[a + 2] * (d + 2 - d - 1)

=

sub[a] * (d) + 

sub[a + 1] * (1) +

sub[a + 2] * (1)

즉 어떤 체인에 대해서 한번에 구할 수 있게 공식이 만들어짐.

그러니까 segtree 범위에서는 그냥 해당 범위 다 더한거만 있으면 됨. depth 처리는 알아서 할게.

---

test input

5 2

0 0 0 1 1

1 2 2 1


---

[1, 3]

sub[1] * 0 + sub[2] + sub[3]

[2, 3] + sub[1] * depth

수정이 조금 필요함

두 가지 케이스로 분류

1. 내 체인, 상위 체인
2. 내 체인의 나(첫 노드)에 대해 서브노드 처리 해줘야함
3. 그 뒤부턴 처리 안해줘도 됨. 상위 체인에서도 마찬가지.

나의 sub 개수가 1이다 => 나만 있음.

value 더하지 마.

나의 sub 개수가 n이다 => (n - 1) * depth

그리고 이 로직은 지극히 나 중심임.

즉 매번 할때마다 나오는 값은 누적이 되어야한단 뜻.

나 처리에 대해서

만약 흰색 추가면 inner 빼고 더해주는게 맞고

검은색 추가면 현재 남은 애들 더해주는게 맞음.

---

본인 체인 처리 완료했고. 이제 상위 체인들만 남았다. 이럴때 어떻게 되는지 로직 다시 한번 짜보자.

[a, a + 2], a의 depth는 d

(sub[a + 2] - sub[이전 노드]) * (d + 2) + 

(sub[a + 1] - sub[a + 2]) * (d + 1) +

(sub[a] - sub[a + 1]) * d

sub[a] * d +

sub[a + 1] * (1) +

sub[a + 2] * (1) +

sub[이전 노드] * -(d[a + 2])

[a, a + 1] a의 depth는 d

sub[a] * d +

sub[a + 1] +

sub[이전 노드] * -(d + 1)

[a, a] a의 depth는 d

(sub[a] - sub[이전 노드]) * d

sub[a] * d +

sub[이전 노드] * -(d)

---

update에서 반환으로 얻고싶은거

범위 합, sub[left]

이전 노드에 곱해주는건 -d - 둘의 depth 차

update에서 얻을 수 있는 두 가지.

pair<int, int>

left 값, 해당 범위 값.

left값을 어떻게 얻지..? 아 find함수 써야하나..

---

5 5

1 0 0 1 1

1 1 3 2

5 3 5 4 2

output 

0 0 1 1 0 1
