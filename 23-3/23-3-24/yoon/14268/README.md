14268

clarify

내리 칭찬

쿼리 1 : 한 직원이 칭찬 받음

쿼리 2: 한 직원의 칭찬 정도 print

N [2, 100000] M [2, 100000]

`직속 상사의 번호는 자신의 번호보다 작으며` 여기서 힌트를 얻을 수 있지 않을까?

int 범위 내에서 처리 가능.

---

기본 자료구조를 생각해본다면 일반적인 tree에서 lazy propagation 처리를 해주는 게 맞음.

TC 계산

쿼리 1 : O(1)

쿼리 2 : 트리가 이쁘다면 $O(logN)$. 최악은 linear 일 때, $O(N)$

hashmap과 함께라면 쿼리 2 최적화 불가능한가?

근데 시간 제한이 5초인데 $100000^2$ 불가능?

최적화 잘만 처리하면 어떻게든 가능하겠는데

---

일단 내 쿼리 2 로직이 $O(N * M)$임을 인지하고 [힌트](https://www.acmicpc.net/board/view/75464)

`어떤 트리가 주어져 있을 때, 루트에서 시작하여 모든 노드를 DFS로 방문하면서, 방문한 순서를 각 노드의 번호로 부여하면, 모든 노드에 대해 그 노드의 서브트리에 있는 노드는 연속된 구간의 번호를 갖게 됩니다.

따라서, 어떤 트리에서 노드의 서브트리에 대한 업데이트 쿼리를 진행하고자 할 때, DFS 방문순서를 활용하면 서브트리 쿼리를 O(logN)에 진행할 수 있습니다.

이를 오일러 투어 테크닉이라고 부릅니다.`

와.. 근데 잠시만. 이것도 아무튼 최악은 N 아닌가?

---

와 .. 진짜 잠시만

오일러 투어 테크닉을 통해 나온 배열을 segment tree로 처리해주면 되겠구나.

이렇게 되면 query1, 2 둘 다 $O(logN)$ 만에 가능.

---

solution

오일러 투어 테크닉을 통해서 사원 id와 오일러 id 매칭. (사원 id를 받으면 오일러 id를 뱉어야하니까 key가 사원 id)

오일러 배열을 통해서 segment tree 구축.

해당 사원이 몇명의 부하를 지니는지 값 들어가 있고

i번째 직원이 칭찬 받으면 [i, i + 부하 수]까지 lazy propagation으로 값 더해줘.

---

왜 틀렸지? 반드시 맞는데.

어차피 쿼리 2는 point query니까 범위 파트에선 딱히 고려할 필요 없다고 생각했는데.

아.. dfs에서 idx 실수 났음.. ㅎㅎ