13515

i번 정점 색을 비꾸면서 어떤 데이터가 필요할까?

연결된 정점의 개수는 어떻게 구할까?

세그 노드 => 서브 트리의 연결된 정점 개수

만약 세그 노드에 저렇게 값이 저장되어있다면

위로 올라가는것만 생각해주면 되는데..

체인에서 연결됐는지 이분탐색으로 가능한가?

segment tree with laazy propagation?

세그노드를 두개로 나눠서.

seg1 => 서브 트리의 연결된 정점 개수

seg2 => range update, point find
    체인 범위에 해당 노드에 대한 정보로 업데이트. (노드 idx, 업데이트된 노드 색깔 정보)

특정 점에서 find를 하면 그 체인에서 가장 먼 같은 색 정점 보여주기?

근데 이렇게 하면 시간제한 2초 가능할까?

seg1 => pair<int, int>로 두면 안되나? 연결된 흰색 노드, 연결된 검은색 노드

그렇게되면 makeSeg에서 first는 싹다 0, second는 서브 노드 개수만큼(이게 말이 되나?).

---

일단 seg1 부터 생각해보자.

**range update**

나부터 위로 연결된 것들까지 range update

체이닝 이용하면 $O(log^2 N)$ ??

이렇게 range update를 해놓으면

find할 때, 같은 색 최상위 노드 찾아서 값만 출력하면 됨. O(log N)

젤 위 노드를 어떻게 찾을까.

만약 내 top 노드가 색이 달라. 그럼 이 체인 내부에 있다는 얘기고

체인은 길이가 N이 될 수도 있으니까 서칭 방법 생각해야지.

---

범위 업뎃? 내 자식한테 값 받아야하는데? 내 자식값은 그대로 두는 판단 어때?

seg[root]= (흰색 서브트리, 검은색 서브트리)

젤 위에 노드 찾기

체이닝 + sqrt decomposition?

버킷으로 관리한다면 노드 색깔 변경에 O(1), find에 chain마다 $\sqrt N$이니까 find $O(log N * \sqrt N)$

즉 range update에는 현재 연결된 탑 노드 찾기 + 해당 탑 노드까지 범위 더해주기

Q1 TC : $O(log N * \sqrt N + log^2 N)$

Q2 TC : $O(log N * \sqrt N + log N)$

---

solution

이제 쿼리를 받기 전에 segment tree 만들어줄건데

in, out으로 처리하고,

seg first가 검은색, second가 흰색.

---

bucket 관리를 어떻게 할지 인데..

1. 체인마다 버켓 따로 처리한다.
2. 전체 N개 노드에 대해 버켓으로 처리한다.

2번으로 생각해보자면 단순히 생각해도 이게 더 복잡하겠는데? 1번으로 가보자.

dfs2할때, top에 대해서 가장 밑 idx도 알아놓아.

그러면 체인의 시작점, 끝점을 알 수 있고, 체인 개수도 알 수 있음. 그걸로 sqrt decomposition 하면 될듯?

bucketIdx 탑 노드는 그에 맞는 버켓 번호를 받는다.

그럼 이제 각 버켓은 개수에 맞게 버켓 개수를 등록한다.

버켓 바깥은 1번부터, 안쪽은 0번 버켓부터 시작한다.
bucket[][0] = 1 ~ 300
bucket[][1] = 301 ~ 600

---

1번 쿼리 업데이트 처리해줄건데

1. 현 체인 처리
   현 체인의 내 위치를 찾는다.
   버켓 갱신해준다.
2. 중간 체인 처리
3. 끝 체인 처리


---

7
1 2
1 3
2 4
2 5
3 6
3 7
4
2 1
1 1
2 2
2 3

6
1 2
1 3
1 4
1 5
2 6
4
1 2
1 2
2 6

---

내 색깔 1

내 위 색깔 0 / 1

아 잠만 햇갈리네.

seg 노드엔 머가 들어있냐면

(나 포함) 연결된 검은색, 흰색 개수

그럼 업데이트 해줄 때,

나 위의 무언가부터 시작해서 값 더해주고 빼주고 해줘야하나?

바뀐 '나'는 +1, -1 해주면 되고

나 바로 위는

바뀌기 전, 빼기 해줄 거를 빼주고
바뀌고, 더하기 해준 거를 더해줘

조상들은 어디까지?

내 부모색깔 같은거 쭉 + 다른 조상 하나.

updateSeg 로직만 바꿔.



