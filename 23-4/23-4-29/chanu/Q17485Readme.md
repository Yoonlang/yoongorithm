### 풀이

dp로 풀면 됨

연속 방향은 불가하기떄문에 이 조건을 만족하는 식을 만들어야함

왼위에서 현재 노드로 왔다면 중간, 오위에서 온 과거노드의 값을 이용해야함

난 이걸 %를 이용해서 식을 이쁘게 만들었음
(k+1)%3, (k+2)%3


```java
dp[i][j][k] = Math.min(dp[i-dir[k][0]][j-dir[k][1]][(k+1)%3], dp[i-dir[k][0]][j-dir[k][1]][(k+2)%3]) + weights[i][j];

```